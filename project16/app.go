package main

import (
	"fmt"
)

// 進制與位運算
func main() {
	fmt.Println("============")
	var byteVar byte = 255 // byte的最大值為255
	fmt.Printf("255 的二進制為：%b\n", byteVar)

	// 八進制，golang的表示法為0開頭
	var octalVal int = 0123
	fmt.Printf("八進制123轉十進制為：%v\n", octalVal)

	// 十六進制，golang的表示法為0x或0X開頭
	var hexVal int = 0xfa0
	fmt.Printf("十六進制fa0轉十進制為：%v\n", hexVal)

	// 二進制 1101 轉十進制
	//    1 * 2^3
	//    1 * 2^2
	//    0 * 2^1
	// +) 1 * 2^0
	// -----------
	// 8 + 4 + 0 + 1 = 13

	// 八進制 123 轉十進制
	//    1 * 8^2
	//    2 * 8^1
	// +) 3 * 8^0
	// -----------
	// 64 + 16 + 3 = 83

	// 十六進制 cf9 轉十進制（a => 10, b => 11, c => 12, d => 13, e => 14, f => 15
	//    12 * 16^2
	//    15 * 16^1
	// +)  9 * 16^0
	// -----------
	// 3072 + 240 + 9 = 3321

	// 十進制轉其他進制，不停除，搜集餘數，倒過來即是
	// 十進制 57 轉 二進制
	// 57 / 2 = 28 .. 1
	// 28 / 2 = 14 .. 0
	// 14 / 2 =  7 .. 0
	//  7 / 2 =  3 .. 1
	//  3 / 2 =  1 .. 1
	//  1 / 2 =  0 .. 1
	// 57 = 111001

	// 十進制 轉 八進制 同上
	// 十進制 轉 十六進制 同上

	// 二進制 轉 八進制
	// 每三個一組
	// 111010 => 111 010
	// 111 = 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 4 + 2 + 1 = 7
	// 010 = 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 0 + 2 + 0 = 2
	// 111010 => 72

	// 二進制 轉 十六進制
	// 每四個一組
	// 10111010 => 1011 1010
	// 1011 = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 8 + 0 + 2 + 1 = b
	// 1010 = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 8 + 0 + 2 + 0 = a
	// 10111010 => ba

	// 八進制 轉 二進制
	// 每一位轉三位
	// 307 => 11 000 111
	// 3 => 011
	// 0 => 000
	// 7 => 111

	// 十六進制 轉 二進制
	// 每一位轉四位
	// c0 => 1100 0000
	// c => 1100
	// 0 => 0000

	// 原碼、反碼、補碼
	// 整數  1 => 0000 0001
	// 整數 -1 => 1000 0001

	// 正數的原碼、反碼、補碼相同
	// 負數的反碼：符號位不動，其餘0, 1交換
	// -1 的反碼：1111 1110
	// 負數的補碼：反碼加一
	// -1 的補碼：1111 1111

	// 0的反碼、補碼都為0
	// 計算機算數都是用補碼計算

	// 位運算 &, |, ^
	// & (AND): 兩位為1，為1，其餘則0
	// | (OR): 兩位有1，為1，其餘則0
	// ^ (XOR): 兩位為1為0，為1，則0

	// 都是使用補碼做計算，所以每個數都要先轉成補碼，運算完後再轉回原碼
	// 但因為正數的補碼跟原碼一樣，所以計算時可直接拿原碼計算
	n1 := 2
	n2 := 3
	fmt.Printf("2的二進制：%08b\n", n1)                   // 00000010
	fmt.Printf("3的二進制：%08b\n", n2)                   // 00000011
	fmt.Printf("2 & 3：%d, 二進制：%08b\n", n1&n2, n1&n2) // 00000010 -> 2
	fmt.Printf("2 | 3：%d, 二進制：%08b\n", n1|n2, n1|n2) // 00000011 -> 3
	fmt.Printf("2 ^ 3：%d, 二進制：%08b\n", n1^n2, n1^n2) // 00000001 -> 1

	// 負數需轉成補碼，計算完後需轉回原碼
	n3 := -2
	fmt.Printf("-2的二進制：%08b\n", n3)                   // 原碼：1000 0010，反碼：1111 1101，補碼：1111 1110
	fmt.Printf("-2 ^ 2：%d, 二進制：%08b\n", n3^n1, n3^n1) // 1111 1110 ^ 0000 0010 => 1111 1100（補碼）=> 1111 1011（反碼）=> 1000 0100

	// 左移運算
	// 符號位不變，低位補零
	fmt.Printf("1 << 2 等於 0000 0001 << 2 等於 %d(%08b)\n", 1<<2, 1<<2)    // 4(00000100)
	fmt.Printf("-1 << 2 等於 1000 0001 << 2 等於 %d(%08b)\n", -1<<2, -1<<2) // -4(10000100)
	// 右移運算
	// 低位捨去，符號位補高位
	fmt.Printf("1 >> 2 等於 0000 0001 >> 2 等於 %d(%08b)\n", 1>>2, 1>>2) // 0(00000000)
	// 1000 0001 -> (反碼)1111 1110 -> (補碼)1111 1111 -> (右移二)1001 1111 -> (高位補符號)1111 1111 -> (反碼)1111 1110 -> (原碼)1000 0001
	fmt.Printf("-1 >> 2 等於 1000 0001 >> 2 等於 %d(%08b)\n", -1>>2, -1>>2) // -1(10000001)
}
